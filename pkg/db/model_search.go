// Code generated by mfd-generator v0.6.0; DO NOT EDIT.

//nolint:all
//lint:file-ignore U1000 ignore unused code, it's generated
package db

import (
	"time"

	"github.com/go-pg/pg/v10"
	"github.com/go-pg/pg/v10/orm"
)

const condition = "?.? = ?"

// base filters
type applier func(query *orm.Query) (*orm.Query, error)

type search struct {
	appliers []applier
}

func (s *search) apply(query *orm.Query) {
	for _, applier := range s.appliers {
		query.Apply(applier)
	}
}

func (s *search) where(query *orm.Query, table, field string, value interface{}) {
	query.Where(condition, pg.Ident(table), pg.Ident(field), value)
}

func (s *search) WithApply(a applier) {
	if s.appliers == nil {
		s.appliers = []applier{}
	}
	s.appliers = append(s.appliers, a)
}

func (s *search) With(condition string, params ...interface{}) {
	s.WithApply(func(query *orm.Query) (*orm.Query, error) {
		return query.Where(condition, params...), nil
	})
}

// Searcher is interface for every generated filter
type Searcher interface {
	Apply(query *orm.Query) *orm.Query
	Q() applier

	With(condition string, params ...interface{})
	WithApply(a applier)
}

type AdminRoleSearch struct {
	search

	ID            *int
	RoleName      *string
	CreatedAt     *time.Time
	IDs           []int
	RoleNameILike *string
}

func (ars *AdminRoleSearch) Apply(query *orm.Query) *orm.Query {
	if ars == nil {
		return query
	}
	if ars.ID != nil {
		ars.where(query, Tables.AdminRole.Alias, Columns.AdminRole.ID, ars.ID)
	}
	if ars.RoleName != nil {
		ars.where(query, Tables.AdminRole.Alias, Columns.AdminRole.RoleName, ars.RoleName)
	}
	if ars.CreatedAt != nil {
		ars.where(query, Tables.AdminRole.Alias, Columns.AdminRole.CreatedAt, ars.CreatedAt)
	}
	if len(ars.IDs) > 0 {
		Filter{Columns.AdminRole.ID, ars.IDs, SearchTypeArray, false}.Apply(query)
	}
	if ars.RoleNameILike != nil {
		Filter{Columns.AdminRole.RoleName, *ars.RoleNameILike, SearchTypeILike, false}.Apply(query)
	}

	ars.apply(query)

	return query
}

func (ars *AdminRoleSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if ars == nil {
			return query, nil
		}
		return ars.Apply(query), nil
	}
}

type AdminSearch struct {
	search

	ID                *int
	Login             *string
	Email             *string
	PasswordHash      *string
	RoleID            *int
	Status            *int
	CreatedAt         *time.Time
	IDs               []int
	LoginILike        *string
	EmailILike        *string
	PasswordHashILike *string
}

func (as *AdminSearch) Apply(query *orm.Query) *orm.Query {
	if as == nil {
		return query
	}
	if as.ID != nil {
		as.where(query, Tables.Admin.Alias, Columns.Admin.ID, as.ID)
	}
	if as.Login != nil {
		as.where(query, Tables.Admin.Alias, Columns.Admin.Login, as.Login)
	}
	if as.Email != nil {
		as.where(query, Tables.Admin.Alias, Columns.Admin.Email, as.Email)
	}
	if as.PasswordHash != nil {
		as.where(query, Tables.Admin.Alias, Columns.Admin.PasswordHash, as.PasswordHash)
	}
	if as.RoleID != nil {
		as.where(query, Tables.Admin.Alias, Columns.Admin.RoleID, as.RoleID)
	}
	if as.Status != nil {
		as.where(query, Tables.Admin.Alias, Columns.Admin.Status, as.Status)
	}
	if as.CreatedAt != nil {
		as.where(query, Tables.Admin.Alias, Columns.Admin.CreatedAt, as.CreatedAt)
	}
	if len(as.IDs) > 0 {
		Filter{Columns.Admin.ID, as.IDs, SearchTypeArray, false}.Apply(query)
	}
	if as.LoginILike != nil {
		Filter{Columns.Admin.Login, *as.LoginILike, SearchTypeILike, false}.Apply(query)
	}
	if as.EmailILike != nil {
		Filter{Columns.Admin.Email, *as.EmailILike, SearchTypeILike, false}.Apply(query)
	}
	if as.PasswordHashILike != nil {
		Filter{Columns.Admin.PasswordHash, *as.PasswordHashILike, SearchTypeILike, false}.Apply(query)
	}

	as.apply(query)

	return query
}

func (as *AdminSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if as == nil {
			return query, nil
		}
		return as.Apply(query), nil
	}
}

type LogTypeSearch struct {
	search

	ID            *int
	TypeName      *string
	IDs           []int
	TypeNameILike *string
}

func (lts *LogTypeSearch) Apply(query *orm.Query) *orm.Query {
	if lts == nil {
		return query
	}
	if lts.ID != nil {
		lts.where(query, Tables.LogType.Alias, Columns.LogType.ID, lts.ID)
	}
	if lts.TypeName != nil {
		lts.where(query, Tables.LogType.Alias, Columns.LogType.TypeName, lts.TypeName)
	}
	if len(lts.IDs) > 0 {
		Filter{Columns.LogType.ID, lts.IDs, SearchTypeArray, false}.Apply(query)
	}
	if lts.TypeNameILike != nil {
		Filter{Columns.LogType.TypeName, *lts.TypeNameILike, SearchTypeILike, false}.Apply(query)
	}

	lts.apply(query)

	return query
}

func (lts *LogTypeSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if lts == nil {
			return query, nil
		}
		return lts.Apply(query), nil
	}
}

type ServiceLogSearch struct {
	search

	ID           *int
	TypeID       *int
	ErrorCode    *int
	Message      *string
	ServiceID    *int
	UserID       *int64
	CreatedAt    *time.Time
	IDs          []int
	MessageILike *string
}

func (sls *ServiceLogSearch) Apply(query *orm.Query) *orm.Query {
	if sls == nil {
		return query
	}
	if sls.ID != nil {
		sls.where(query, Tables.ServiceLog.Alias, Columns.ServiceLog.ID, sls.ID)
	}
	if sls.TypeID != nil {
		sls.where(query, Tables.ServiceLog.Alias, Columns.ServiceLog.TypeID, sls.TypeID)
	}
	if sls.ErrorCode != nil {
		sls.where(query, Tables.ServiceLog.Alias, Columns.ServiceLog.ErrorCode, sls.ErrorCode)
	}
	if sls.Message != nil {
		sls.where(query, Tables.ServiceLog.Alias, Columns.ServiceLog.Message, sls.Message)
	}
	if sls.ServiceID != nil {
		sls.where(query, Tables.ServiceLog.Alias, Columns.ServiceLog.ServiceID, sls.ServiceID)
	}
	if sls.UserID != nil {
		sls.where(query, Tables.ServiceLog.Alias, Columns.ServiceLog.UserID, sls.UserID)
	}
	if sls.CreatedAt != nil {
		sls.where(query, Tables.ServiceLog.Alias, Columns.ServiceLog.CreatedAt, sls.CreatedAt)
	}
	if len(sls.IDs) > 0 {
		Filter{Columns.ServiceLog.ID, sls.IDs, SearchTypeArray, false}.Apply(query)
	}
	if sls.MessageILike != nil {
		Filter{Columns.ServiceLog.Message, *sls.MessageILike, SearchTypeILike, false}.Apply(query)
	}

	sls.apply(query)

	return query
}

func (sls *ServiceLogSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if sls == nil {
			return query, nil
		}
		return sls.Apply(query), nil
	}
}

type ServiceTypeSearch struct {
	search

	ID            *int
	TypeName      *string
	IDs           []int
	TypeNameILike *string
}

func (sts *ServiceTypeSearch) Apply(query *orm.Query) *orm.Query {
	if sts == nil {
		return query
	}
	if sts.ID != nil {
		sts.where(query, Tables.ServiceType.Alias, Columns.ServiceType.ID, sts.ID)
	}
	if sts.TypeName != nil {
		sts.where(query, Tables.ServiceType.Alias, Columns.ServiceType.TypeName, sts.TypeName)
	}
	if len(sts.IDs) > 0 {
		Filter{Columns.ServiceType.ID, sts.IDs, SearchTypeArray, false}.Apply(query)
	}
	if sts.TypeNameILike != nil {
		Filter{Columns.ServiceType.TypeName, *sts.TypeNameILike, SearchTypeILike, false}.Apply(query)
	}

	sts.apply(query)

	return query
}

func (sts *ServiceTypeSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if sts == nil {
			return query, nil
		}
		return sts.Apply(query), nil
	}
}

type ServiceUserSearch struct {
	search

	ID            *int
	TgID          *int
	Nickname      *string
	CreatedAt     *time.Time
	IDs           []int
	NicknameILike *string
}

func (sus *ServiceUserSearch) Apply(query *orm.Query) *orm.Query {
	if sus == nil {
		return query
	}
	if sus.ID != nil {
		sus.where(query, Tables.ServiceUser.Alias, Columns.ServiceUser.ID, sus.ID)
	}
	if sus.TgID != nil {
		sus.where(query, Tables.ServiceUser.Alias, Columns.ServiceUser.TgID, sus.TgID)
	}
	if sus.Nickname != nil {
		sus.where(query, Tables.ServiceUser.Alias, Columns.ServiceUser.Nickname, sus.Nickname)
	}
	if sus.CreatedAt != nil {
		sus.where(query, Tables.ServiceUser.Alias, Columns.ServiceUser.CreatedAt, sus.CreatedAt)
	}
	if len(sus.IDs) > 0 {
		Filter{Columns.ServiceUser.ID, sus.IDs, SearchTypeArray, false}.Apply(query)
	}
	if sus.NicknameILike != nil {
		Filter{Columns.ServiceUser.Nickname, *sus.NicknameILike, SearchTypeILike, false}.Apply(query)
	}

	sus.apply(query)

	return query
}

func (sus *ServiceUserSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if sus == nil {
			return query, nil
		}
		return sus.Apply(query), nil
	}
}

type ServiceSearch struct {
	search

	ID          *int
	Name        *string
	TypeID      *int
	ApiKey      *string
	Status      *int
	CreatedAt   *time.Time
	IDs         []int
	NameILike   *string
	ApiKeyILike *string
}

func (ss *ServiceSearch) Apply(query *orm.Query) *orm.Query {
	if ss == nil {
		return query
	}
	if ss.ID != nil {
		ss.where(query, Tables.Service.Alias, Columns.Service.ID, ss.ID)
	}
	if ss.Name != nil {
		ss.where(query, Tables.Service.Alias, Columns.Service.Name, ss.Name)
	}
	if ss.TypeID != nil {
		ss.where(query, Tables.Service.Alias, Columns.Service.TypeID, ss.TypeID)
	}
	if ss.ApiKey != nil {
		ss.where(query, Tables.Service.Alias, Columns.Service.ApiKey, ss.ApiKey)
	}
	if ss.Status != nil {
		ss.where(query, Tables.Service.Alias, Columns.Service.Status, ss.Status)
	}
	if ss.CreatedAt != nil {
		ss.where(query, Tables.Service.Alias, Columns.Service.CreatedAt, ss.CreatedAt)
	}
	if len(ss.IDs) > 0 {
		Filter{Columns.Service.ID, ss.IDs, SearchTypeArray, false}.Apply(query)
	}
	if ss.NameILike != nil {
		Filter{Columns.Service.Name, *ss.NameILike, SearchTypeILike, false}.Apply(query)
	}
	if ss.ApiKeyILike != nil {
		Filter{Columns.Service.ApiKey, *ss.ApiKeyILike, SearchTypeILike, false}.Apply(query)
	}

	ss.apply(query)

	return query
}

func (ss *ServiceSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if ss == nil {
			return query, nil
		}
		return ss.Apply(query), nil
	}
}

type ServiceAdminaSearch struct {
	search

	ServiceID  *int
	AdminID    *int
	AssignedAt *time.Time
	ServiceIDs []int
	AdminIDs   []int
}

func (sas *ServiceAdminaSearch) Apply(query *orm.Query) *orm.Query {
	if sas == nil {
		return query
	}
	if sas.ServiceID != nil {
		sas.where(query, Tables.ServiceAdmina.Alias, Columns.ServiceAdmina.ServiceID, sas.ServiceID)
	}
	if sas.AdminID != nil {
		sas.where(query, Tables.ServiceAdmina.Alias, Columns.ServiceAdmina.AdminID, sas.AdminID)
	}
	if sas.AssignedAt != nil {
		sas.where(query, Tables.ServiceAdmina.Alias, Columns.ServiceAdmina.AssignedAt, sas.AssignedAt)
	}
	if len(sas.ServiceIDs) > 0 {
		Filter{Columns.ServiceAdmina.ServiceID, sas.ServiceIDs, SearchTypeArray, false}.Apply(query)
	}
	if len(sas.AdminIDs) > 0 {
		Filter{Columns.ServiceAdmina.AdminID, sas.AdminIDs, SearchTypeArray, false}.Apply(query)
	}

	sas.apply(query)

	return query
}

func (sas *ServiceAdminaSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if sas == nil {
			return query, nil
		}
		return sas.Apply(query), nil
	}
}
